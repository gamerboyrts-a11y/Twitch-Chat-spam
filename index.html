<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Spam Tracker (Fixed)</title>
    <style>
        body { background: linear-gradient(to bottom, #18181b, #0e0e10); color: #efeff1; font-family: 'Inter', Helvetica, Arial, sans-serif; text-align: center; padding: 20px; overflow-x: hidden; min-height: 100vh; margin: 0; }
        
        /* Input Section */
        .controls { background: #1f1f23; padding: 20px; border-radius: 10px; display: inline-block; box-shadow: 0 4px 6px rgba(0,0,0,0.3); margin-bottom: 20px; }
        input { padding: 12px; font-size: 16px; border-radius: 6px; border: 1px solid #3a3a3d; background: #0e0e10; color: white; width: 200px; outline: none; }
        input:focus { border-color: #9146ff; }
        button { padding: 12px 24px; font-size: 16px; margin-left: 10px; border-radius: 6px; border: none; background-color: #9146ff; color: white; cursor: pointer; font-weight: bold; transition: background 0.2s; }
        button:hover { background-color: #772ce8; }

        /* Toggles & Timer */
        .settings-row { margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 20px; flex-wrap: wrap; }
        
        .toggle-group { display: flex; align-items: center; gap: 8px; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #3a3a3d; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #9146ff; }
        input:checked + .slider:before { transform: translateX(26px); }
        .label-text { font-size: 14px; color: #adadb8; font-weight: 600; }

        .timer-group input { width: 60px; padding: 8px; margin-left: 5px; text-align: center; }
        
        /* Status Bar */
        #status-container { max-width: 600px; margin: 0 auto 30px; text-align: center; }
        #status-text { font-size: 14px; color: #adadb8; margin-bottom: 8px; display: block; min-height: 20px; }
        #progress-bg { width: 100%; height: 6px; background: #3a3a3d; border-radius: 3px; overflow: hidden; }
        #progress-bar { width: 0%; height: 100%; background: #00e6cc; transition: width 0.3s ease; box-shadow: 0 0 8px #00e6cc; }

        /* Cards */
        .top-container { display: flex; justify-content: center; gap: 30px; flex-wrap: wrap; margin-top: 20px; }
        .top-card { 
            width: 220px; height: 260px; padding: 20px; 
            border-radius: 16px; 
            background: #1f1f23;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            position: relative;
            border: 2px solid transparent;
            transition: transform 0.2s;
        }
        .top-card:hover { transform: translateY(-5px); }
        
        .rank-badge { position: absolute; top: -15px; background: #18181b; padding: 5px 15px; border-radius: 20px; border: 2px solid; font-weight: bold; font-size: 18px; }
        
        #card1 { border-color: #eec22e; box-shadow: 0 0 20px rgba(238, 194, 46, 0.15); }
        #card1 .rank-badge { border-color: #eec22e; color: #eec22e; }
        
        #card2 { border-color: #c0c0c0; box-shadow: 0 0 20px rgba(192, 192, 192, 0.15); }
        #card2 .rank-badge { border-color: #c0c0c0; color: #c0c0c0; }
        
        #card3 { border-color: #cd7f32; box-shadow: 0 0 20px rgba(205, 127, 50, 0.15); }
        #card3 .rank-badge { border-color: #cd7f32; color: #cd7f32; }

        .content-area { flex-grow: 1; display: flex; align-items: center; justify-content: center; width: 100%; overflow: hidden; }
        .content-area img { height: 112px; max-width: 100%; object-fit: contain; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5)); }
        .content-area span { font-size: 36px; font-weight: 800; word-break: break-word; line-height: 1.1; }
        
        .percent-bar-bg { width: 100%; height: 8px; background: #3a3a3d; border-radius: 4px; overflow: hidden; margin-top: 15px; }
        .percent-bar-fill { height: 100%; background: white; transition: width 0.5s ease; }
        .percent-text { margin-top: 8px; font-size: 20px; font-weight: bold; font-family: monospace; }
        
        #card1 .percent-bar-fill { background: #eec22e; }
        #card2 .percent-bar-fill { background: #c0c0c0; }
        #card3 .percent-bar-fill { background: #cd7f32; }
    </style>
</head>
<body>
    <h1>Live Spam Tracker</h1>
    
    <div class="controls">
        <div>
            <input id="channel" placeholder="Channel (e.g. xqc)" onkeydown="if(event.key==='Enter') connect()" />
            <button onclick="connect()">Connect</button>
        </div>
        <div class="settings-row">
            <div class="toggle-group">
                <label class="switch">
                    <!-- Default Checked: Show Emotes Only -->
                    <input type="checkbox" id="emoteToggle" checked onchange="updateDisplay()">
                    <span class="slider"></span>
                </label>
                <span class="label-text">Show Emotes Only</span>
            </div>
            
            <div class="toggle-group timer-group">
                <span class="label-text">Time Window (s):</span>
                <input type="number" id="timerInput" placeholder="Off" value="30" min="1" onchange="updateTimer()">
                <button onclick="manualReset()" style="padding: 6px 12px; font-size: 14px;">Clear</button>
            </div>
        </div>
    </div>

    <div id="status-container">
        <span id="status-text">Ready to connect</span>
        <div id="progress-bg"><div id="progress-bar"></div></div>
    </div>

    <div class="top-container">
        <!-- Card 1 -->
        <div id="card1" class="top-card">
            <div class="rank-badge">#1</div>
            <div class="content-area" id="content1">-</div>
            <div style="width:100%">
                <div class="percent-bar-bg"><div class="percent-bar-fill" id="bar1" style="width:0%"></div></div>
                <div class="percent-text" id="perc1">0%</div>
            </div>
        </div>
        <!-- Card 2 -->
        <div id="card2" class="top-card">
            <div class="rank-badge">#2</div>
            <div class="content-area" id="content2">-</div>
            <div style="width:100%">
                <div class="percent-bar-bg"><div class="percent-bar-fill" id="bar2" style="width:0%"></div></div>
                <div class="percent-text" id="perc2">0%</div>
            </div>
        </div>
        <!-- Card 3 -->
        <div id="card3" class="top-card">
            <div class="rank-badge">#3</div>
            <div class="content-area" id="content3">-</div>
            <div style="width:100%">
                <div class="percent-bar-bg"><div class="percent-bar-fill" id="bar3" style="width:0%"></div></div>
                <div class="percent-text" id="perc3">0%</div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let spams = new Map();
        const TAU = 300000; // 5 min half-life for score weight
        const MAX_TIMESTAMPS = 150;
        let emoteMap = new Map();
        let updateInterval = null;
        
        // REMOVED: let resetInterval = null; 

        function setProgress(pct, msg) {
            document.getElementById('progress-bar').style.width = pct + '%';
            if (msg) document.getElementById('status-text').textContent = msg;
        }

        async function fetchJson(url) {
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error(res.status);
                return await res.json();
            } catch (e) {
                const proxy = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                const res = await fetch(proxy);
                return await res.json();
            }
        }

        async function load7TV(channel) {
            emoteMap.clear();
            setProgress(15, `Fetching ID for ${channel}...`);
            try {
                const users = await fetchJson(`https://api.ivr.fi/v2/twitch/user?login=${channel}`);
                if (!users[0]?.id) throw new Error('User not found');
                const id = users[0].id;

                setProgress(50, `Found ID ${id}. Getting 7TV emotes...`);
                const tvUser = await fetchJson(`https://7tv.io/v3/users/twitch/${id}`);
                const setId = tvUser.emote_set?.id;
                
                if (setId) {
                    const setData = await fetchJson(`https://7tv.io/v3/emote-sets/${setId}`);
                    (setData.emotes || []).forEach(e => {
                        emoteMap.set(e.name.toLowerCase(), `https://cdn.7tv.app/emote/${e.id}/3x.webp`);
                    });
                    setProgress(100, `Connected! ${emoteMap.size} emotes loaded.`);
                } else {
                    setProgress(100, `Connected (No 7TV set found)`);
                }
            } catch (err) {
                console.error(err);
                setProgress(100, `Connected (7TV error: ${err.message})`);
            }
        }

        function addSpam(word) {
            let item = spams.get(word) || { ts: [] };
            const now = Date.now();
            item.ts.push(now);
            if (item.ts.length > MAX_TIMESTAMPS) item.ts = item.ts.slice(-MAX_TIMESTAMPS);
            spams.set(word, item);
        }

        function getScore(word) {
            const item = spams.get(word);
            if (!item) return 0;
            const now = Date.now();
            // Score is weighted by how recent the messages are
            return item.ts.reduce((sum, t) => sum + Math.exp(-(now - t) / TAU), 0);
        }

        function updateDisplay() {
            // --- NEW LOGIC START: Time Window Pruning ---
            const timerInput = document.getElementById('timerInput').value;
            // If timer has a valid value, filter out old data
            if (timerInput && timerInput > 0) {
                const limitMs = parseInt(timerInput) * 1000;
                const now = Date.now();

                for (const [key, item] of spams) {
                    // Keep only timestamps that are newer than (now - limit)
                    const newTs = item.ts.filter(t => (now - t) < limitMs);
                    
                    if (newTs.length === 0) {
                        // If all instances of this word are too old, remove it entirely
                        spams.delete(key);
                    } else if (newTs.length < item.ts.length) {
                        // If we filtered some out, update the array
                        item.ts = newTs;
                    }
                }
            }
            // --- NEW LOGIC END ---

            const onlyEmotes = document.getElementById('emoteToggle').checked;

            let items = Array.from(spams.keys()).map(k => ({
                key: k,
                score: getScore(k),
                isEmote: emoteMap.has(k)
            }));

            // Filter noise
            items = items.filter(i => i.score > 0.05);
            if (onlyEmotes) {
                items = items.filter(i => i.isEmote);
            }

            // Sort by score
            items.sort((a, b) => b.score - a.score);

            // Calc Trend Sum (Top 15 for relative bars)
            const trendSum = items.slice(0, 15).reduce((sum, i) => sum + i.score, 0);

            // Render top 3
            for (let i = 0; i < 3; i++) {
                const contentEl = document.getElementById(`content${i+1}`);
                const percTextEl = document.getElementById(`perc${i+1}`);
                const barEl = document.getElementById(`bar${i+1}`);

                if (i >= items.length) {
                    contentEl.innerHTML = '<span style="color:#333">-</span>';
                    percTextEl.innerText = '0%';
                    barEl.style.width = '0%';
                    continue;
                }

                const item = items[i];
                // Calculate percentage based on total activity
                const pct = trendSum > 0 ? Math.min(100, Math.round((item.score / trendSum) * 100)) : 0;

                if (item.isEmote) {
                    contentEl.innerHTML = `<img src="${emoteMap.get(item.key)}" alt="${item.key}">`;
                } else {
                    contentEl.innerHTML = `<span>${item.key}</span>`;
                }

                percTextEl.innerText = `${pct}%`;
                barEl.style.width = `${pct}%`;
            }
        }

        function manualReset() {
            spams.clear();
            updateDisplay();
            const oldText = document.getElementById('status-text').textContent;
            document.getElementById('status-text').textContent = "Board Cleared!";
            setTimeout(() => { document.getElementById('status-text').textContent = oldText; }, 1000);
        }

        function updateTimer() {
            // Trigger an immediate update so the user sees the effect of changing the timer
            updateDisplay();
            const val = document.getElementById('timerInput').value;
            console.log(`Window updated to ${val}s`);
        }

        function connect() {
            const channel = document.getElementById('channel').value.trim().toLowerCase();
            if (!channel) return alert("Enter channel name");

            if (ws) { ws.close(); }
            manualReset();
            
            // NO setInterval here anymore. The updateDisplay loop handles the window.

            setProgress(5, "Connecting...");

            const nick = `justinfan${Math.floor(Math.random() * 80000) + 1000}`;
            ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');

            ws.onopen = () => {
                ws.send('PASS schmoo');
                ws.send(`NICK ${nick}`);
                ws.send(`JOIN #${channel}`);
                load7TV(channel);
            };

            ws.onmessage = (e) => {
                const lines = e.data.split('\r\n');
                lines.forEach(line => {
                    if (line.startsWith('PING')) ws.send('PONG :tmi.twitch.tv');
                    if (line.includes(`PRIVMSG #${channel}`)) {
                        const msg = line.split(`PRIVMSG #${channel} :`)[1];
                        if (msg) {
                            msg.trim().split(/\s+/).forEach(t => {
                                const clean = t.toLowerCase().replace(/[^a-z0-9]/g, ""); 
                                if (clean.length > 0) addSpam(clean);
                                // Also track original casing if needed, but we store keys as lowercase mostly
                                if (t.length > 0 && t.toLowerCase() !== clean) addSpam(t.toLowerCase());
                            });
                        }
                    }
                });
            };
            
            if (!updateInterval) updateInterval = setInterval(updateDisplay, 1000);
        }
    </script>
</body>
</html>
